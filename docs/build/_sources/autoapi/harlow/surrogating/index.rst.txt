:py:mod:`harlow.surrogating`
============================

.. py:module:: harlow.surrogating


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   surrogate_model/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   harlow.surrogating.BatchIndependentGaussianProcess
   harlow.surrogating.BayesianNeuralNetwork
   harlow.surrogating.DeepKernelMultiTaskGaussianProcess
   harlow.surrogating.GaussianProcessTFP
   harlow.surrogating.ModelListGaussianProcess
   harlow.surrogating.MultiTaskGaussianProcess
   harlow.surrogating.NeuralNetwork
   harlow.surrogating.Surrogate
   harlow.surrogating.VanillaGaussianProcess




.. py:class:: BatchIndependentGaussianProcess(training_max_iter=100, learning_rate=0.1, input_transform=TensorTransform, output_transform=TensorTransform, min_loss_rate=None, optimizer=None, mean=None, covar=None, show_progress=True, silence_warnings=False, fast_pred_var=False, dev=None)

   Bases: :py:obj:`Surrogate`

   Utility class to generate a surrogate composed of multiple independent
   Gaussian processes with the same covariance and likelihood:
   https://docs.gpytorch.ai/en/stable/examples/03_Multitask_Exact_GPs/Batch_Independent_Multioutput_GP.html

   .. rubric:: Notes

   * This model must be initialized with data
   * The `.fit(X, y)` method replaces the current `train_X` and `train_y`
   with its arguments every time it is called.
   * The `.update(X, y)` method will append the new X and y training tensors
   to the existing `train_X`, `train_y` and perform the fitting.
   * Both `.fit()` and `.update()` will re-instantiate a new model. There
   is likely a better solution to this.

   TODO:
   * GpyTorch probably has existing functionality for updating and refitting
   models. This is likely the prefered approach and should replace the current
   approach where the model is redefined at each call to `fit()` or `.update()`.
   * Rewrite to use the existing Gaussian process surrogate class
   * Add type hinting
   * Improve docstrings

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = True

      

   .. py:method:: create_model()


   .. py:method:: _fit(train_X, train_y, **kwargs)


   .. py:method:: _predict(X_pred, return_std=False, **kwargs)


   .. py:method:: sample_posterior(n_samples=1)


   .. py:method:: _update(new_X, new_y, **kwargs)


   .. py:method:: get_noise()



.. py:class:: BayesianNeuralNetwork(epochs=10, batch_size=32, input_transform=Identity, output_transform=Identity, **kwargs)

   Bases: :py:obj:`Surrogate`

   Abstract base class for the surrogate models. Each surrogate
   model must initialize the abstact base class using the following
   statement during initialization:

       super().__init__(
           input_transform=input_transform,
           output_transform=output_transform
       )

   All surrogates must also implement the following methods:
   * `create_model`
   * `_fit`
   * `_predict`
   * `_update`

   .. py:attribute:: learning_rate_initial
      :annotation: = 0.01

      

   .. py:attribute:: learning_rate_update
      :annotation: = 0.001

      

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = False

      

   .. py:method:: kernel_divergence_fn(q, p, _)


   .. py:method:: bias_divergence_fn(q, p, _)


   .. py:method:: create_model(input_dim=(2, ), output_dim=1, activation='relu', learning_rate=0.01)


   .. py:method:: _fit(X, y, **kwargs)


   .. py:method:: _update(X_new, y_new, **kwargs)


   .. py:method:: _predict(X, return_std=False, iterations=100, **kwargs)


   .. py:method:: get_predictions()



.. py:class:: DeepKernelMultiTaskGaussianProcess(input_transform=TensorTransform, output_transform=TensorTransform, training_max_iter=100, learning_rate=0.1, min_loss_rate=None, optimizer=None, mean=None, covar=None, show_progress=True, silence_warnings=False, fast_pred_var=False, dev=None, layers=None, num_mixtures=4)

   Bases: :py:obj:`Surrogate`

   !!!!!!!!!!!! IN PROGRESS !!!!!!!!!!!!!!!

   MultiTask Deep kernel learning Gaussian process, based on this single-output
   example:
   https://docs.gpytorch.ai/en/stable/examples/02_Scalable_Exact_GPs/
   Simple_GP_Regression_With_LOVE_Fast_Variances_and_Sampling.html

   .. rubric:: Notes

   * This model must be initialized with data
   * The `.fit(X, y)` method replaces the current `train_X` and `train_y`
   with its arguments every time it is called.
   * The `.update(X, y)` method will append the new X and y training tensors
   to the existing `train_X`, `train_y` and perform the fitting.
   * Both `.fit()` and `.update()` will re-instantiate a new model. There
   is likely a better solution to this.

   TODO:
   * GpyTorch probably has existing functionality for updating and refitting
   models. This is likely the prefered approach and should replace the current
   approach where the model is redefined at each call to `fit()` or `.update()`.
   * Rewrite to use the existing Gaussian process surrogate class
   * Add type hinting
   * Improve docstrings

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = True

      

   .. py:method:: create_model()


   .. py:method:: _fit(train_X, train_y, **kwargs)


   .. py:method:: _predict(X_pred, return_std=False, **kwargs)


   .. py:method:: sample_posterior(n_samples=1)


   .. py:method:: _update(new_X, new_y, **kwargs)


   .. py:method:: get_noise()



.. py:class:: GaussianProcessTFP(train_iterations=50, input_transform=Identity, output_transform=Identity, **kwargs)

   Bases: :py:obj:`Surrogate`

   Abstract base class for the surrogate models. Each surrogate
   model must initialize the abstact base class using the following
   statement during initialization:

       super().__init__(
           input_transform=input_transform,
           output_transform=output_transform
       )

   All surrogates must also implement the following methods:
   * `create_model`
   * `_fit`
   * `_predict`
   * `_update`

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = False

      

   .. py:attribute:: is_torch
      :annotation: = False

      

   .. py:method:: create_model()


   .. py:method:: optimize_parameters(verbose=0)


   .. py:method:: target_log_prob(amplitude, length_scale, observation_noise_variance)


   .. py:method:: _fit(X, y, **kwargs)


   .. py:method:: _predict(X, iterations=50, return_std=False, return_samples=False, **kwargs)


   .. py:method:: _update(new_X, new_y, **kwargs)



.. py:class:: ModelListGaussianProcess(model_names=None, training_max_iter=100, learning_rate=0.1, input_transform=TensorTransform, output_transform=TensorTransform, min_loss_rate=None, optimizer=None, mean=None, covar=None, list_params=None, show_progress=True, silence_warnings=False, fast_pred_var=False, dev=None)

   Bases: :py:obj:`Surrogate`

   Utility class to generate a surrogate composed of multiple independent
   Gaussian processes. Currently uses GPyTorch.

   It is assumed that the training inputs are common between the N_task GPs,
   but not all features are used in each GP.

   .. rubric:: Notes

   * This model must be initialized with data
   * The `.fit(X, y)` method replaces the current `train_X` and `train_y`
   with its arguments every time it is called.
   * The `.update(X, y)` method will append the new X and y training tensors
   to the existing `train_X`, `train_y` and perform the fitting.
   * Both `.fit()` and `.update()` will re-instantiate a new model. There
   is likely a better solution to this.

   TODO:
   * GpyTorch probably has existing functionality for updating and refitting
   models. This is likely the prefered approach and should replace the current
   approach where the model is redefined at each call to `fit()` or `.update()`.
   * Rewrite to use the existing Gaussian process surrogate class
   * Add type hinting
   * Improve docstrings

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = True

      

   .. py:method:: create_model()


   .. py:method:: _fit(train_X, train_y, **kwargs)


   .. py:method:: _predict(X_pred, return_std=False, as_array=False, **kwargs)


   .. py:method:: sample_posterior(n_samples=1)


   .. py:method:: _update(new_X, new_y, **kwargs)


   .. py:method:: get_noise()



.. py:class:: MultiTaskGaussianProcess(num_tasks=None, training_max_iter=100, learning_rate=0.1, input_transform=TensorTransform, output_transform=TensorTransform, min_loss_rate=None, optimizer=None, mean=None, covar=None, show_progress=True, silence_warnings=False, fast_pred_var=False, dev=None)

   Bases: :py:obj:`Surrogate`

   !!!!!!!!!!!! IN PROGRESS !!!!!!!!!!!!!!!

   Utility class to generate a surrogate composed of multiple correlated
   Gaussian processes:
   https://docs.gpytorch.ai/en/stable/examples/03_Multitask_Exact_GPs/Multitask_GP_Regression.html

   .. rubric:: Notes

   * This model must be initialized with data
   * The `.fit(X, y)` method replaces the current `train_X` and `train_y`
   with its arguments every time it is called.
   * The `.update(X, y)` method will append the new X and y training tensors
   to the existing `train_X`, `train_y` and perform the fitting.
   * Both `.fit()` and `.update()` will re-instantiate a new model. There
   is likely a better solution to this.

   TODO:
   * GpyTorch probably has existing functionality for updating and refitting
   models. This is likely the prefered approach and should replace the current
   approach where the model is redefined at each call to `fit()` or `.update()`.
   * Rewrite to use the existing Gaussian process surrogate class
   * Add type hinting
   * Improve docstrings

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = True

      

   .. py:method:: create_model()


   .. py:method:: _fit(train_X, train_y, **kwargs)


   .. py:method:: _predict(X_pred, return_std=False, **kwargs)


   .. py:method:: sample_posterior(n_samples=1)


   .. py:method:: _update(new_X, new_y, **kwargs)


   .. py:method:: get_noise()



.. py:class:: NeuralNetwork(epochs=10, batch_size=32, loss='mse', input_transform=Identity, output_transform=Identity, **kwargs)

   Bases: :py:obj:`Surrogate`

   Class for Neural Networks.
   The class takes an uncompiled tensorflow Model, e.g.



   .. py:attribute:: learning_rate_update
      :annotation: = 0.001

      

   .. py:attribute:: is_probabilistic
      :annotation: = False

      

   .. py:attribute:: is_multioutput
      :annotation: = True

      

   .. py:attribute:: is_torch
      :annotation: = False

      

   .. py:method:: create_model(input_dim=(2, ), output_dim=1, activation='relu', learning_rate=0.01)


   .. py:method:: _fit(X, y, **kwargs)


   .. py:method:: _update(X_new, y_new, **kwargs)


   .. py:method:: _predict(X, **kwargs)



.. py:class:: Surrogate(input_transform: Optional[harlow.utils.transforms.Transform] = Identity, output_transform: Optional[harlow.utils.transforms.Transform] = Identity, **kwargs)

   Bases: :py:obj:`abc.ABC`

   Abstract base class for the surrogate models. Each surrogate
   model must initialize the abstact base class using the following
   statement during initialization:

       super().__init__(
           input_transform=input_transform,
           output_transform=output_transform
       )

   All surrogates must also implement the following methods:
   * `create_model`
   * `_fit`
   * `_predict`
   * `_update`

   .. py:property:: is_probabilistic
      :abstractmethod:


   .. py:property:: is_multioutput
      :abstractmethod:


   .. py:property:: is_torch
      :abstractmethod:


   .. py:method:: _fit(X, y, **kwargs)
      :abstractmethod:


   .. py:method:: _predict(X, **kwargs) -> Union[numpy.ndarray, torch.tensor]
      :abstractmethod:


   .. py:method:: _update(new_X, new_y, **kwargs)
      :abstractmethod:


   .. py:method:: create_model()
      :abstractmethod:


   .. py:method:: save(destination: pathlib.Path)
      :abstractmethod:


   .. py:method:: load(source: pathlib.Path)
      :staticmethod:
      :abstractmethod:


   .. py:method:: check_inputs(X, y=None)
      :staticmethod:


   .. py:method:: fit(X: numpy.ndarray, y: numpy.ndarray, **kwargs)

      Calls the `_fit()` method of the surrogate model instance after applying
      transforms and checking inputs. A user specified surrogate model only
      has to implement the `_fit()` method. Note that `fit()` is a user-facing
      method and should not be called from within the class.


   .. py:method:: update(X: numpy.ndarray, y: numpy.ndarray, **kwargs)

      Calls the `_update()` method of the surrogate model instance after applying
      transforms and checking inputs. A user specified surrogate model only
      has to implement the `_update()` method. Note that `update()` is a user-facing
      method and should not be called from within the class.


   .. py:method:: predict(X: numpy.ndarray, return_std: Optional = False, **kwargs) -> Union[torch.tensor, numpy.ndarray, Tuple[torch.tensor, torch.tensor], Tuple[numpy.ndarray, numpy.ndarray]]

      Calls the `_predict()` method of the surrogate model instance after applying
      transforms and checking inputs. A user specified surrogate model only
      has to implement the `_predict()` method. Note that `predict()` is a user-facing
      method and should not be called from within the class.



.. py:class:: VanillaGaussianProcess(train_restarts: int = 10, kernel=kernel, noise_std=None, input_transform=Identity, output_transform=Identity, **kwargs)

   Bases: :py:obj:`Surrogate`

   Abstract base class for the surrogate models. Each surrogate
   model must initialize the abstact base class using the following
   statement during initialization:

       super().__init__(
           input_transform=input_transform,
           output_transform=output_transform
       )

   All surrogates must also implement the following methods:
   * `create_model`
   * `_fit`
   * `_predict`
   * `_update`

   .. py:attribute:: is_probabilistic
      :annotation: = True

      

   .. py:attribute:: is_multioutput
      :annotation: = False

      

   .. py:attribute:: is_torch
      :annotation: = False

      

   .. py:attribute:: kernel
      

      

   .. py:method:: create_model()


   .. py:method:: save(destination: pathlib.Path)


   .. py:method:: load(source: pathlib.Path)
      :staticmethod:


   .. py:method:: _fit(X, y, **kwargs)


   .. py:method:: get_noise()


   .. py:method:: _predict(X, return_std=False, **kwargs)


   .. py:method:: _update(new_X, new_y, **kwargs)



